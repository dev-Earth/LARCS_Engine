# LARCS リファレンス

このドキュメントは、3Dロボティクスシミュレーションアプリケーション「LARCS」の設計と開発計画をまとめたものです。

## 1. 概要 (Overview)

**LARCS**は、`sim2real`（シミュレーションから実世界へ）と`digital twin`（現実世界のデジタルコピー）の実現を目的とした、先進的なロボティクスシミュレーションロボットコントロールプラットフォームです。
深層強化学習にはAIのライブラリが豊富であり、生産性が高い「Python」を採用。
このLARCS内部にはC++/cudaを使用し、リアルタイム性を確保します。

LARCS : Leaning Autonomous Robot control System

### 1.1. プロジェクトの目的

*   **高忠実度なシミュレーション:** 実世界の物理法則やセンサー特性を忠実に再現し、シミュレーションと実機の差異を最小限に抑えます。
*   **効率的なAI開発:** シミュレーション環境でAI（特に深層学習モデル）を高速に学習・検証し、実機へスムーズに展開します。

### 1.2. 主な特徴

*   **脱ROS/ROS2:** 通信ミドルウェアには、モダンで高性能な **`zenoh`** を採用し、シンプルで高速なデータ通信を実現します。

*   **Isaac Simからの着想:** NVIDIA Isaac Simを参考に、シミュレータコア **`LARCS_Matrix`** と強化学習環境 **`LARCS_DRL`** を独自に開発します。
*   **高性能物理エンジン:** 物理演算には **NVIDIA PhysX** を採用し、リアルな挙動をシミュレートします。

---

## 2. アーキテクチャ (Architecture)

### 2.1. 基本コンポーネント

*   **`LARCS_RUNTIME` (ランタイム, zenohなどのミドルウェア)**
    *   このLARCS全体を動かすためのランタイムミドルウェア。
    *   ROS/ROS2を使用しない分の必要なシステムを作動。
    *   c++を使用する。
    *   サーバサイド推論ソフトウェア`LARCS_Matrix`と、ロボットシミュレーション環境``

*   **`LARCS_Matrix` (シミュレータコア):**
    *   現実の競技フィールドやロボットの動作環境を3D空間に構築します。
    *   ロボットのアセンブリデータをAutodesk fusionからインポートする。インポートにはnvidia issacのonShape importerを模したLARCS_Bridgeシステムを使用する。(別章説明)

*   **`LARCS_DRL` (深層強化学習API : Deep Reinforcement Learning):**
    *   `LARCS_Matrix` 内に組み込まれ、ロボットのAIを学習させるための環境を提供します。
    *   GPUアクセラレーションを活用し、深層学習を高速に実行します。
    *   深層強化学習のコーディングにはAIライブラリが豊富なPythonを使用します。
    *   IDEはvscodeを使用します。`LARCS_DRL`との連携をとるためのvscodeの拡張機能を作成。

*   **`LARCS_Bridge` (アセンブリデータインポートAPI拡張機能 for fusion)**
    *   `LARCS_Matrix`に直接取り込めるようAPIを提供します。
    *   `LARCS_Matrix`のAssembly Importer for fusionが押されたら、APIを通じてデータをインポートする。
    *   別章で説明する。

    [LARCS_Bridge 必要データ](#LARCS_Bridge-必要データ定義)

*   **センサーシミュレーション:**
    *   Lidar, カメラセンサー (e.g.RealSense,OAK-D), IMU, エンコーダー(AMT10)といった各種センサーを仮想的に再現します。
    *   センサーのノイズモデルや物理特性をパラメータで調整可能にし、実機との整合性を高めます。

### 2.2. 実機 (Real Robot)

*   **制御システム:**
    *   **メインPC (Ubuntu):** センサーデータ処理。
    *   **マイクロコントローラー (ESP32):** モーター制御や緊急停止（E-STOP）など、リアルタイム性が求められる処理を担当。
    
*   **通信:** メインPCとマイコンはシリアル通信で接続し、安定した命令伝達を行います。

### 2.3. 通信 (Communication)

*   **ミドルウェア `zenoh`:**
    *   システム全体のデータ交換を担います。軽量かつ低遅延で、シミュレータ、実機、開発PC間の通信を支えます。
*   **ネットワーク構成:**
    *   **開発・テスト時:** 開発PCがロボットPCを兼任し、シリアル経由でマイコンを直接制御します。
    *   **大会・本番時:** 推論サーバーがWi-Fi経由でロボットPCに指示を送信。開発PCはモニタリングに徹します。

### 2.4. 開発環境

*   **3D仮想空間ソフトウェア"LARCS_Matrix"**
    * vulkanを用いた3D仮想シミュレーションソフト
    * Autodesk Fusionからのロボットアセンブリデータやフィールドのインポートを行い、3D仮想空間上に配置する。
    * マウス操作、座標系はFusion準拠。
    * 機能を追加する上でアプリ開発を用意にすべくコンポーネンツを用いる。
    * アプリケーションのアイコンには `docs/larcsicon.png` を使用します。
    *   （注: このIDEは内部利用を想定し、一般配布は行いません。）

*   **強化学習環境"LARCS_DRL"**
  * LARCS_Matrixに組み込まれ、Matrix内のロボットを深層学習、強化学習を行う。
  * 深層強化学習(DRL)の開発に伴うコーディングはプラグインを介したCLionを用いる。

*   **CLion,LARCS_Matrixブリッジプラグイン"LARCS_Bridge"**
    * LARCS_DRLのDRL開発において、高度なコーディングを可能とするCLionとMatrix間のブリッジを行うプラグイン

---

## 3. ワークフロー (Workflow)

### 3.1. CADからシミュレーションへ

1.  **モデリング:** Autodesk Fusionを使い、ロボットの3Dモデル（アセンブリ）を作成します。
2.  **エクスポート:** 自作のFusionアドオンを使用し、以下のファイルを一括で出力します。
    *   `{assemblyname}.stl`: 形状データ
    *   `{assemblyname}.dae`: 形状と当たり判定データ
    *   `{assemblyname}_joint.json`: 関節（ジョイント）情報
3.  **インポート:** `LARCS_Matrix` がこれらのファイルを読み込み、シミュレーション空間にロボットを正確に再現します。

### 3.2. AIの学習と実機への展開

1.  **学習:** `LARCS_DRL` を使い、シミュレーション内でAIモデルを繰り返し学習させます。（シミュレーションはn倍速での実行も可能）
2.  **デプロイ:** 学習済みのAIモデルを推論サーバーに配置します。
3.  **Sim2Real:** 推論サーバーは、`zenoh` を介してリアルタイムに推論結果を実機ロボットへ送信し、ロボットが自律的にタスクを遂行します。

---

## 4. 開発ロードマップ (Development Roadmap)
子フェーズに分割して段階的に開発を進める。
- Phase 1: 完了基準 : LARCS_Matrixを起動できる。LARCS_Engine のコア (C++ Runtime, Zenoh 通信) を整備。
    - 1-1: LARCS_Matrixウィンドウ表示できるまで。
      - 1280x720で表示できる。
      - ウィンドウにLARCS_Matrixの文字を表示できる。
      - スプラッシュ・スクリーンを表示することができる。
      - タスクバーのiconを設定できる。
    注意：のちにvulkanで描画する。openglは使用しない。
    
    - 1-2. LARCS_Engine のコア (C++ Runtime, Zenoh 通信) を整備
      - `ZenohNode` クラス: init/shutdown/publish/subscribe を提供し、C++/外部から簡単に扱える ABI を提供する。
      - API 互換性: 文字列/バイナリ両対応、コールバックはスレッドセーフ設計。
      - テスト: `larcs_cli ping` / `larcs_cli pong` などの最小アプリで localhost と WiFi 上の疎通を確認。
      - `Runtime` 基本クラス: Initialize -> Loop -> Terminate を提供。
      - ループ制御: 目標周波数（例: 100Hz）での時間管理、`Clock` クラス（steady_clock ベース）、sleep 処理は `std::this_thread::sleep_for` 等で低負荷維持。
      - テスト: 周波数とドリフトの単体テストを用意。

    - 1-2. LARCS_Engine C++ ランタイムとLARCS_Matirx間の連帯
        - アプリが `larcs_engine` をサブプロセスとして起動・監視（stdout/stderr 捕捉、exit code）。最も簡易で安定。
        - 成果: 上記いずれかをデフォルト連携方法として確定し、通信プロトコル（トピック名、コマンド／ステータス定義）を文書化する。
    
このあとの開発フェーズは随時更新していく。

---

## 5. 技術スタック (Technology Stack)

*   **プログラミング言語:** C++ (コアエンジン),その他使用する場合は随時追加。
*   **物理エンジン:** NVIDIA PhysX
*   **通信ミドルウェア:** zenoh
*   **ビルドシステム:** CMake (C++)
*   **CADソフトウェア:** Autodesk Fusion

---

## 6. 開発・実行環境構成

### 基本構成
```
開発PC 兼 推論サーバー 兼 ロボットPC
 |
 +- (シリアル通信) --> マイコン (ESP32)
 |                      |
 |                      +- (CAN通信) --> 電源管理ボード -> モータードライバ -> モーター
 |                      |
 |                      +- (CAN通信) --> センサーモニタ -> エンコーダー, IMU
 |
 +- (Ethernet) ----> センサー (Lidar, カメラ)
```

### 将来的な構成（資金調達後）
```
推論サーバー
 |
 +- (Wi-Fi) --> ロボットPC
 |               |
 |               +- (シリアル通信) --> マイコン (ESP32) ... [基本構成と同様]
 |               |
 |               +- (Ethernet) ----> センサー (Lidar, カメラ)
 |
 +- (Wi-Fi) --> 開発PC (ノード監視, ステータス表示, AI管理、ロボット監視)
```

## 7. コンポーネント定義

### 

### LARCS_Bridge-必要データ定義