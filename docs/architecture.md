# LARCS アーキテクチャ

## 概要

LARCS（Learning Autonomous Robot Control System）は、競技環境向けの自律ロボットシステムを **開発・テスト・デプロイ** するためのモジュール型フレームワークです。ROSに依存しないアーキテクチャを採用しており、シミュレーションから実機へスムーズに移行できます。

## システム構成

### 全体アーキテクチャ

```
┌─────────────┐      ┌─────────────┐      ┌─────────────┐
│   Simulation│      │    Real     │      │    Server   │
│    System   │◄────►│   Hardware  │◄────►│   Control   │
└─────────────┘      └─────────────┘      └─────────────┘
       ▲                    ▲                     ▲
       │                    │                     │
       └────────────────────┴─────────────────────┘
                     LARCS Runtime
```

### コアモジュール

#### 1. **larcs-runtime**（通信 & 時刻）
runtime モジュールは、基盤となる機能を提供します。

- **時刻管理**: 単調増加時計（monotonic）とシステム時刻の取り扱い
- **Publisher/Subscriber**: メッセージパッシング基盤（現状はスケルトン）
- **Logger**: spdlog 統合による構造化ログ
- **将来**: ネットワークトランスポート、シリアライズ、ノードライフサイクル

#### 2. **larcs-msgs**（メッセージ定義）
通信メッセージは Protocol Buffers で定義されます。

- **common**: Time, Header
- **geometry**: Vector3, Quaternion, Pose, Twist
- **control**: TrajectoryPlan, WheelState
- **health**: SystemHealth, ComponentStatus

#### 3. **larcs-tools**（コマンドラインユーティリティ）

- **larcs-ping**: ネットワーク疎通のテスト
- **larcs-record**: メッセージ記録（スケルトン）
- **larcs-replay**: メッセージ再生（スケルトン）

## 通信設計

### メッセージフロー

```
Control Station         Robot System
┌─────────────┐        ┌─────────────┐
│  Trajectory │───────►│   Control   │
│   Planner   │        │  Executor   │
└─────────────┘        └─────────────┘
       ▲                      │
       │                      ▼
┌─────────────┐        ┌─────────────┐
│  Telemetry  │◄───────│   Sensors   │
│   Monitor   │        │  & Wheels   │
└─────────────┘        └─────────────┘
```

### 通信チャネル

1. **Control チャネル**: 高頻度（50〜100Hz）の軌道・制御コマンド
2. **Telemetry チャネル**: センサデータ、車輪状態、オドメトリ
3. **Health チャネル**: システム状態監視（1〜10Hz）
4. **Perception チャネル**: 画像・LiDAR 等（可変レート）

## 制御サイクル設計

### 典型的な制御ループ（100Hz）
```
1. 軌道プラン（TrajectoryPlan）を受信
2. 現在時刻に対応する目標姿勢を補間
3. 車輪速度を計算
4. モータコントローラへコマンド送信
5. エンコーダフィードバック（WheelState）を取得
6. オドメトリを更新
7. テレメトリを Publish
```

### 時刻同期

- すべてのメッセージに `Header`（タイムスタンプ）を持たせる
- 制御ループでは単調増加時計（monotonic time）を使用
- ログ/診断では壁時計（wall clock time）を使用

## シミュレーションから実機への移行

### 開発ワークフロー

```
Phase 1: Simulation Development
  ├─ シミュレーション上でアルゴリズムを開発
  ├─ 仮想センサ/アクチュエータでテスト
  └─ テストシナリオを記録

Phase 2: Hardware Integration
  ├─ シミュレーション部品をハードウェアドライバに置き換え
  ├─ 同じメッセージインタフェースを維持
  └─ 記録したシナリオを実機で再生

Phase 3: Field Testing
  ├─ 競技ロボットへデプロイ
  ├─ テレメトリで監視
  └─ 実データを記録して解析
```

### 重要原則

1. **インタフェースの一貫性**: シミュレーションと実機で同じ API
2. **メッセージ互換性**: protobuf 定義を厳密に共通化
3. **時間抽象化**: runtime がタイミング詳細を吸収
4. **モジュール性**: 実装を差し替えても上位は変更不要

## モジュール依存

```
tools/          → runtime, msgs
runtime/        →（スタンドアロン、依存は最小）
msgs/           → protobuf のみ
```

## 将来拡張

### 計画している機能（Rev.1+）

- ネットワークトランスポート層（UDP/TCP）
- 分散ノード・アーキテクチャ
- リアルタイムスケジューリング対応
- ハードウェア抽象化レイヤ
- シミュレーション統合レイヤ
- 競技特化モジュール:
  - 経路計画
  - 自己位置推定
  - 物体検出
  - 戦略実行

### 拡張ポイント

- protobuf によるカスタムメッセージ
- プラガブルなトランスポート
- カスタム時間ソース（例: シミュレーション時間）
- ロガーバックエンド（DB、クラウド等）

## 設計目標

1. **最小依存**: コア runtime を軽量に保つ
2. **ROS 非依存**: ROS 不要（ただしブリッジで相互運用は可能）
3. **CLion 統合**: IDE での体験を重視
4. **クロスプラットフォーム**: Linux を主対象（必要に応じて拡張）
5. **性能**: 必要ならハードリアルタイム運用も視野
6. **保守性**: 明確な構造とドキュメント
